import React from 'react';
import { mount } from 'enzyme';
import localforage from 'localforage';
import ignoredMessages from '../../../testHelpers/MockConsole';

import entryProxy from '../../../services/EntryProxy';

import ModalEditEntry from '../ModalEditEntry';
import updateWrapper from '../../../testHelpers/EnzymeHelper';

jest.mock('../../../services/EntryProxy');
jest.mock('localforage');

describe('ModalEditEntry', () => {
  beforeAll(() => {
    ignoredMessages.length = 0;
    ignoredMessages.push('[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry. Using default message as fallback.');
    ignoredMessages.push('a test was not wrapped in act');
  });

  afterEach(() => {
    entryProxy.createOrSaveEntry.mockReset();
    entryProxy.existEntry.mockReset();
  });

  const equipment = {
    _uiId: 'an id generated by the front',
    name: 'engine',
    brand: 'Nanni',
    model: 'N3.30',
    age: 2563,
    installation: new Date(2019, 6, 10),
    ageAcquisitionType: 1,
    ageUrl: '',
  };

  const task = {
    _uiId: 'an_id_created_by_the_front_end_and_for_the_front_end',
    name: 'Vidange',
    usagePeriodInHour: 500,
    periodInMonth: 12,
    description: "Changer l'huile",
    nextDueDate: new Date(2020, 6, 10),
    level: 0,
    usageInHourLeft: undefined,
  };

  const entry = {
    _uiId: 'an_entry_id',
    name: 'vidange',
    date: new Date(2019, 9, 25),
    age: 400,
    remarks: 'oil was clean',
    taskUiId: 'an_id_created_by_the_front_end_and_for_the_front_end',
    equipmentUiId: 'an id generated by the front',
  };

  it('should render', () => {
    // Arrange
    entryProxy.existEntry.mockImplementation(async () => Promise.resolve(true));

    const onSavedEntry = jest.fn();
    const onDeletedEntry = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    // Act
    const modalEditEntry = mount(<ModalEditEntry equipment={equipment} task={task} entry={entry} visible={isVisible} saveEntry={onSavedEntry} deleteEntry={onDeletedEntry} toggle={toggleFn} />);

    // Assert
    expect(modalEditEntry).toMatchSnapshot();
  });

  it('Should save the entry using the entry proxy when clicking on Save', async () => {
    // Arrange
    entryProxy.existEntry.mockImplementation(async () => Promise.resolve(true));
    jest.spyOn(entryProxy, 'createOrSaveEntry').mockImplementation(async (equipmentId, taskId, newEntry) => Promise.resolve(newEntry));

    const onSavedEntry = jest.fn();

    const onDeletedEntry = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    const modalEditEntry = mount(<ModalEditEntry equipment={equipment} task={task} entry={entry} visible={isVisible} saveEntry={onSavedEntry} deleteEntry={onDeletedEntry} toggle={toggleFn} />);
    const myForm = modalEditEntry.find('Memo(MyForm)');

    // Act
    myForm.simulate('submit');
    await updateWrapper(modalEditEntry);

    // Assert
    expect(entryProxy.createOrSaveEntry).toBeCalledTimes(1);
    expect(onSavedEntry).toBeCalledTimes(1);
  });
});

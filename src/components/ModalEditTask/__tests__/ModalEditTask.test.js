import React from 'react';
import { mount } from 'enzyme';

// eslint-disable-next-line no-unused-vars
import localforage from 'localforage';
import ignoredMessages from '../../../testHelpers/MockConsole';

import taskProxy from '../../../services/TaskProxy';

import ModalEditTask from '../ModalEditTask';
import updateWrapper from '../../../testHelpers/EnzymeHelper';

jest.mock('../../../services/TaskProxy');
jest.mock('localforage');

describe('ModalEditTask', () => {
  beforeAll(() => {
    ignoredMessages.length = 0;
    ignoredMessages.push('[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry. Using default message as fallback.');
    ignoredMessages.push('a test was not wrapped in act');
  });

  afterEach(() => {
    taskProxy.createOrSaveTask.mockReset();
    taskProxy.existTask.mockReset();
    taskProxy.deleteTask.mockReset();
  });

  const equipment = {
    _uiId: 'an id generated by the front',
    name: 'engine',
    brand: 'Nanni',
    model: 'N3.30',
    age: 2563,
    installation: new Date(2019, 6, 10),
    ageAcquisitionType: 1,
    ageUrl: '',
  };

  const task = {
    _uiId: 'an_id_created_by_the_front_end_and_for_the_front_end',
    name: 'Vidange',
    usagePeriodInHour: 500,
    periodInMonth: 12,
    description: "Changer l'huile",
    nextDueDate: new Date(2020, 6, 10),
    level: 0,
    usageInHourLeft: undefined,
  };

  it('should render 3 buttons (cancel/save/delete) when we edit an existing task', async () => {
    // Arrange
    taskProxy.existTask.mockImplementation(async () => Promise.resolve(true));

    const onTaskSaved = jest.fn();
    const onTaskDeleted = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    // Act
    const modalEditTask = mount(<ModalEditTask equipment={equipment} task={task} visible={isVisible} onTaskSaved={onTaskSaved} onTaskDeleted={onTaskDeleted} toggle={toggleFn} />);
    await updateWrapper(modalEditTask);

    // Assert
    expect(modalEditTask).toMatchSnapshot();
    expect(modalEditTask.props().visible).toBe(true);
    expect(modalEditTask.find('ModalFooter').find('Button').length).toBe(3);
  });

  it('should render 2 buttons (cancel/create) when we create a new entry', async () => {
    // Arrange
    taskProxy.existTask.mockImplementation(async () => Promise.resolve(false));

    const onTaskSaved = jest.fn();
    const onTaskDeleted = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    // Act
    const modalEditTask = mount(<ModalEditTask equipment={equipment} task={task} visible={isVisible} onTaskSaved={onTaskSaved} onTaskDeleted={onTaskDeleted} toggle={toggleFn} />);
    await updateWrapper(modalEditTask);

    // Assert
    expect(modalEditTask.props().visible).toBe(true);
    expect(modalEditTask.find('ModalFooter').find('Button').length).toBe(2);
  });

  it('Should save the task using the task proxy when clicking on Save', async () => {
    // Arrange
    taskProxy.existTask.mockImplementation(async () => Promise.resolve(true));
    jest.spyOn(taskProxy, 'createOrSaveTask').mockImplementation(async (equipmentId, newTask) => Promise.resolve(newTask));

    const onTaskSaved = jest.fn();
    const onTaskDeleted = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    const modalEditTask = mount(<ModalEditTask equipment={equipment} task={task} visible={isVisible} onTaskSaved={onTaskSaved} onTaskDeleted={onTaskDeleted} toggle={toggleFn} />);
    await updateWrapper(modalEditTask);
    const myForm = modalEditTask.find('Memo(MyForm)');

    // Act
    myForm.simulate('submit');
    await updateWrapper(modalEditTask);

    // Assert
    expect(taskProxy.createOrSaveTask).toBeCalledTimes(1);
    expect(onTaskSaved).toBeCalledTimes(1);
    expect(toggleFn).toBeCalledTimes(1);
  });

  it('Should close the modal when clicking on Cancel', async () => {
    // Arrange
    taskProxy.existTask.mockImplementation(async () => Promise.resolve(true));

    const onTaskSaved = jest.fn();
    const onTaskDeleted = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    const modalEditTask = mount(<ModalEditTask equipment={equipment} task={task} visible={isVisible} onTaskSaved={onTaskSaved} onTaskDeleted={onTaskDeleted} toggle={toggleFn} />);
    await updateWrapper(modalEditTask);
    const cancelButton = modalEditTask.find('ModalFooter').find('Button').at(1);

    // Act
    cancelButton.simulate('click');
    await updateWrapper(modalEditTask);

    // Assert
    expect(toggleFn).toBeCalledTimes(1);
  });

  it('The deletion should be preceded by a confirmation message', async () => {
    // Arrange
    taskProxy.existTask.mockImplementation(async () => Promise.resolve(true));

    const onTaskSaved = jest.fn();
    const onTaskDeleted = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    const modalEditTask = mount(<ModalEditTask equipment={equipment} task={task} visible={isVisible} onTaskSaved={onTaskSaved} onTaskDeleted={onTaskDeleted} toggle={toggleFn} />);
    await updateWrapper(modalEditTask);
    const deleteButton = modalEditTask.find('ModalFooter').find('Button').at(2);

    // Act
    deleteButton.simulate('click');
    await updateWrapper(modalEditTask);

    // Assert
    const confirmationModal = modalEditTask.find('ModalYesNoConfimation');
    expect(confirmationModal.props().visible).toBe(true);
  });

  it('Clicking yes on the confirmation should call the entryProxy.delete function', async () => {
    // Arrange
    taskProxy.existTask.mockImplementation(async () => Promise.resolve(true));
    jest.spyOn(taskProxy, 'deleteTask');

    const onTaskSaved = jest.fn();
    const onTaskDeleted = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    const modalEditTask = mount(<ModalEditTask equipment={equipment} task={task} visible={isVisible} onTaskSaved={onTaskSaved} onTaskDeleted={onTaskDeleted} toggle={toggleFn} />);
    await updateWrapper(modalEditTask);
    const deleteButton = modalEditTask.find('ModalFooter').find('Button').at(2);

    deleteButton.simulate('click');
    await updateWrapper(modalEditTask);

    const confirmationModal = modalEditTask.find('ModalYesNoConfimation');
    const yesButton = confirmationModal.find('ActionButton');

    // Act
    yesButton.simulate('click');
    await updateWrapper(modalEditTask);

    // Assert
    expect(taskProxy.deleteTask).toBeCalledTimes(1);
    expect(onTaskDeleted).toBeCalledTimes(1);
    expect(toggleFn).toBeCalledTimes(1);
    expect(modalEditTask.find('ModalYesNoConfimation').props().visible).toBe(false);
  });

  it('Clicking No on the confirmation should not call the entryProxy.delete function but just close the confirmation modal', async () => {
    // Arrange
    taskProxy.existTask.mockImplementation(async () => Promise.resolve(true));
    jest.spyOn(taskProxy, 'deleteTask');

    const onTaskSaved = jest.fn();
    const onTaskDeleted = jest.fn();
    let isVisible = true;
    const toggleFn = jest.fn().mockImplementation(() => {
      isVisible = !isVisible;
    });

    const modalEditTask = mount(<ModalEditTask equipment={equipment} task={task} visible={isVisible} onTaskSaved={onTaskSaved} onTaskDeleted={onTaskDeleted} toggle={toggleFn} />);
    await updateWrapper(modalEditTask);
    const deleteButton = modalEditTask.find('ModalFooter').find('Button').at(2);

    deleteButton.simulate('click');
    await updateWrapper(modalEditTask);

    const confirmationModal = modalEditTask.find('ModalYesNoConfimation');
    const noButton = confirmationModal.find('Button').at(1);

    // Act
    noButton.simulate('click');
    await updateWrapper(modalEditTask);

    // Assert
    expect(taskProxy.deleteTask).toBeCalledTimes(0);
    expect(onTaskDeleted).toBeCalledTimes(0);
    expect(toggleFn).toBeCalledTimes(0);
    expect(modalEditTask.find('ModalYesNoConfimation').props().visible).toBe(false);
  });
});

import ignoredMessages from '../../testHelpers/MockConsole';

import userProxy from '../UserProxy';
import entryProxy from '../EntryProxy';

import equipmentManager from '../EquipmentManager';
import taskManager from '../TaskManager';
import entryManager from '../EntryManager';

import { TaskLevel } from '../../types/Types';

import { sleep } from '../../testHelpers/EnzymeHelper';

jest.mock('../EntryProxy');
jest.mock('../UserProxy');

describe('Test EntryManager', () => {
  const currentEntryListener = jest.fn();
  const entriesListener = jest.fn();

  const equipment = {
    _uiId: 'an id generated by the front 1',
    name: 'engine',
    brand: 'Nanni',
    model: 'N3.30',
    age: 2563,
    installation: new Date(1979, 6, 1),
    ageAcquisitionType: 1,
    ageUrl: '',
  };

  const task = {
    _uiId: 'an_id_created_by_the_front_end_and_for_the_front_end_1',
    name: 'Vidange',
    usagePeriodInHour: 500,
    periodInMonth: 12,
    description: "Changer l'huile",
    nextDueDate: new Date(2020, 3, 29),
    level: TaskLevel.done,
    usageInHourLeft: undefined,
  };

  const task2 = {
    _uiId: 'an_id_created_by_the_front_end_and_for_the_front_end_2',
    name: 'Vidange',
    usagePeriodInHour: 500,
    periodInMonth: 12,
    description: "Changer l'huile",
    nextDueDate: new Date(2020, 3, 29),
    level: TaskLevel.done,
    usageInHourLeft: undefined,
  };

  const entry1 = {
    _uiId: 'an_entry_id_1',
    name: 'vidange',
    date: new Date(2020, 3, 29),
    age: 400,
    remarks: 'oil was clean',
    taskUiId: task._uiId,
    equipmentUiId: equipment._uiId,
  };

  const entry2 = {
    _uiId: 'an_entry_id_2',
    name: 'vidange',
    date: new Date(2020, 2, 29),
    age: 300,
    remarks: 'oil was clean',
    taskUiId: task._uiId,
    equipmentUiId: equipment._uiId,
  };

  const entry3 = {
    _uiId: 'an_entry_id_3',
    name: 'vidange',
    date: new Date(2020, 1, 29),
    age: 200,
    remarks: 'oil was clean',
    taskUiId: task2._uiId,
    equipmentUiId: equipment._uiId,
  };

  beforeAll(() => {
    ignoredMessages.length = 0;
    entryManager.registerOnCurrentEntryChanged(currentEntryListener);
    entryManager.registerOnEquipmentEntriesChanged(entriesListener);
  });

  beforeEach(() => {
    userProxy.getCredentials.mockImplementation(async () => ({ readonly: false }));
  });

  afterEach(async () => {
    entryProxy.fetchAllEntries.mockReset();
    userProxy.getCredentials.mockRestore();

    currentEntryListener.mockReset();
    entriesListener.mockReset();
    await sleep(100);
  });

  describe('getCurrentEntry', () => {
    it('Should return undefined before setting the current equipment', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(() => Promise.resolve([]));

      equipmentManager.setCurrentEquipment(undefined);
      await sleep(200);

      // Act
      const currentEntry = entryManager.getCurrentEntry();

      // Assert
      expect(entryProxy.fetchAllEntries).toBeCalledTimes(0);
      expect(currentEntry).toBeUndefined();
      done();
    });

    it('Should return undefined after setting a current equipment which does not have any entry yet', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(() => Promise.resolve([]));

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      // Act
      const currentEntry = entryManager.getCurrentEntry();

      // Assert
      expect(entryProxy.fetchAllEntries).toBeCalledTimes(1);
      expect(currentEntry).toBeUndefined();
      done();
    });

    it('Should return the oldest entry after setting the current equipment', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      // Act
      const currentEntry = entryManager.getCurrentEntry();

      // Assert
      expect(entryProxy.fetchAllEntries).toBeCalledTimes(1);
      expect(currentEntry).toEqual(entry2);
      done();
    });

    it('Should return undefined when the current equipment becomes undefined.', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      equipmentManager.setCurrentEquipment(undefined);
      await sleep(200);

      // Act
      const currentEntry = entryManager.getCurrentEntry();

      // Assert
      expect(entryProxy.fetchAllEntries).toBeCalledTimes(1);
      expect(currentEntry).toEqual(undefined);
      done();
    });
  });

  describe('setCurrentEntry', () => {
    it('Should notify the listeners when the current entry changed', async (done) => {
      // Arrange

      // Act
      entryManager.setCurrentEntry(entry1);

      // Assert
      expect(currentEntryListener).toBeCalledTimes(1);
      expect(currentEntryListener.mock.calls[0][0]).toBe(entry1);
      done();
    });

    it('Should notify the listeners when the current entry changed', async (done) => {
      // Arrange
      const anotherListener = jest.fn();
      entryManager.registerOnCurrentEntryChanged(anotherListener);

      // Act
      entryManager.setCurrentEntry(entry1);

      // Assert
      expect(anotherListener).toBeCalledTimes(1);
      expect(anotherListener.mock.calls[0][0]).toBe(entry1);

      entryManager.unregisterOnCurrentEntryChanged(anotherListener);
      done();
    });

    it('Should not notify the unregister listener when the current entry changed', async (done) => {
      // Arrange
      const anotherListener = jest.fn();
      entryManager.registerOnCurrentEntryChanged(anotherListener);

      entryManager.setCurrentEntry(entry1);
      entryManager.unregisterOnCurrentEntryChanged(anotherListener);

      // Act
      entryManager.setCurrentEntry(entry2);

      // Assert
      expect(anotherListener).toBeCalledTimes(1);
      expect(anotherListener.mock.calls[0][0]).toBe(entry1);

      done();
    });
  });

  describe('getEquipmentEntries', () => {
    it('should return the entries fetched and sorted by date', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry3, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      // Act
      const entries = entryManager.getEquipmentEntries();

      // Assert
      expect(entries.length).toBe(3);
      expect(entries[0]).toBe(entry3);
      expect(entries[1]).toBe(entry2);
      expect(entries[2]).toBe(entry1);
      done();
    });
  });

  describe('getTaskEntries', () => {
    it('should return the entries related to the current task and sorted by date', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry3, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      taskManager.setCurrentTask(task);
      await sleep(200);

      // Act
      const entries = entryManager.getTaskEntries();

      // Assert
      expect(entries.length).toBe(2);
      expect(entries[0]).toBe(entry2);
      expect(entries[1]).toBe(entry1);
      done();
    });

    it('should return the empty entry array when the current task is undefined', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry3, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      taskManager.setCurrentTask(undefined);
      await sleep(200);

      // Act
      const entries = entryManager.getTaskEntries();

      // Assert
      expect(entries.length).toBe(0);
      done();
    });
  });

  describe('onEntryDeleted', () => {
    it('should remove the entry from the list and it should notify the listeners', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry3, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      taskManager.setCurrentTask(task);

      // Act
      entryManager.onEntryDeleted(entry1);

      // Assert
      const entries = entryManager.getEquipmentEntries();
      expect(entries.length).toBe(2);
      expect(entries.includes(entry1)).toBe(false);
      expect(entriesListener).toBeCalledTimes(2);
      done();
    });

    it('should not notify the unregistered listeners', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry3, entry1]));

      const anotherEntriesListener = jest.fn();
      entryManager.registerOnEquipmentEntriesChanged(anotherEntriesListener);

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      entryManager.unregisterOnEquipmentEntriesChanged(anotherEntriesListener);

      // Act
      entryManager.onEntryDeleted(entry1);

      // Assert
      const entries = entryManager.getEquipmentEntries();
      expect(entries.length).toBe(2);
      expect(entries.includes(entry1)).toBe(false);
      expect(entriesListener).toBeCalledTimes(2);
      done();
    });

    it('should change the current entry when the current entry is deleted', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry3, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      entryManager.setCurrentEntry(entry1);

      // Act
      entryManager.onEntryDeleted(entry1);

      // Assert
      expect(entryManager.getCurrentEntry()).toBe(entry3);
      done();
    });
  });

  describe('onEntrySaved', () => {
    it('should add the entry in the list and it should notify the listeners', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      // Act
      entryManager.onEntrySaved(entry3);

      // Assert
      const entries = entryManager.getEquipmentEntries();
      expect(entries.length).toBe(3);
      expect(entries[0]).toEqual(entry3);
      expect(entriesListener).toBeCalledTimes(2);
      done();
    });

    it('should update the entry from the list and it should notify the listeners', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => Promise.resolve([entry2, entry1]));

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      const copyEntry1 = { ...entry1 };
      copyEntry1.description = 'new description';

      // Act
      entryManager.onEntrySaved(copyEntry1);

      // Assert
      const entries = entryManager.getEquipmentEntries();
      expect(entries.length).toBe(2);
      expect(entries[1]).toEqual(copyEntry1);
      expect(entriesListener).toBeCalledTimes(2);
      done();
    });
  });

  describe('areEntriesLoading', () => {
    it('should be true when fetching the entries', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => {
        await sleep(500);
        return Promise.resolve([entry1, entry2]);
      });

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      // Act
      const areEntriesLoading1 = entryManager.areEntriesLoading();
      await sleep(700);
      const areEntriesLoading2 = entryManager.areEntriesLoading();

      // Assert
      expect(areEntriesLoading1).toBe(true);
      expect(areEntriesLoading2).toBe(false);
      done();
    });

    it('should be false after fetching the tasks unsuccessfully', async (done) => {
      // Arrange
      entryProxy.fetchAllEntries.mockImplementation(async () => {
        await sleep(500);
        return Promise.reject(new Error('an unexpected error'));
      });

      equipmentManager.setCurrentEquipment(equipment);
      await sleep(200);

      // Act
      const areEntriesLoading1 = entryManager.areEntriesLoading();
      await sleep(700);
      const areEntriesLoading2 = entryManager.areEntriesLoading();

      // Assert
      expect(areEntriesLoading1).toBe(true);
      expect(areEntriesLoading2).toBe(false);
      done();
    });
  });
});

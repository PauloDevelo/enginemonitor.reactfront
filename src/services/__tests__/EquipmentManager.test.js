import ignoredMessages from '../../testHelpers/MockConsole';

import userProxy from '../UserProxy';
import equipmentProxy from '../EquipmentProxy';

import assetManager from '../AssetManager';
import equipmentManager from '../EquipmentManager';

import { sleep } from '../../testHelpers/EnzymeHelper';

jest.mock('../EquipmentProxy');
jest.mock('../UserProxy');

describe('Test EquipmentManager', () => {
  const currentEquipmentListener = jest.fn();
  const equipmentsListener = jest.fn();

  const asset = {
    _uiId: 'asset_01',
    name: 'Arbutus',
    brand: 'Aluminium & Techiniques',
    manufactureDate: new Date(1979, 1, 1),
    modelBrand: 'Heliotrope',
  };

  const equipment1 = {
    _uiId: 'an id generated by the front 1',
    name: 'engine',
    brand: 'Nanni',
    model: 'N3.30',
    age: 2563,
    installation: new Date(1979, 6, 1),
    ageAcquisitionType: 1,
    ageUrl: '',
  };

  const equipment2 = {
    _uiId: 'an id generated by the front 2',
    name: 'watermaker',
    brand: 'Katadyn',
    model: 'Power Survivor',
    age: 2320,
    installation: new Date(2017, 11, 23),
    ageAcquisitionType: 1,
    ageUrl: '',
  };

  beforeAll(() => {
    ignoredMessages.length = 0;
    equipmentManager.registerOnCurrentEquipmentChanged(currentEquipmentListener);
    equipmentManager.registerOnEquipmentsChanged(equipmentsListener);
  });

  beforeEach(() => {
    userProxy.getCredentials.mockImplementation(async () => ({ readonly: false }));
  });

  afterEach(async () => {
    equipmentProxy.fetchEquipments.mockReset();
    userProxy.getCredentials.mockRestore();
    currentEquipmentListener.mockReset();
    equipmentsListener.mockReset();
  });

  describe('getCurrentEquipment', () => {
    it('Should return undefined before setting the current asset', (done) => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(() => Promise.resolve([]));

      // Act
      const currentEquipment = equipmentManager.getCurrentEquipment();

      // Assert
      expect(equipmentProxy.fetchEquipments).toBeCalledTimes(0);
      expect(currentEquipment).toBeUndefined();
      done();
    });

    it('Should return undefined after setting a current asset which does not have any equipment yet', async () => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(() => Promise.resolve([]));

      await assetManager.setCurrentAsset(asset);
      await sleep(200);

      // Act
      const currentEquipment = equipmentManager.getCurrentEquipment();

      // Assert
      expect(equipmentProxy.fetchEquipments).toBeCalledTimes(1);
      expect(currentEquipment).toBeUndefined();
    });

    it('Should return the first equipment issued by fetchEquipments after setting the current asset', async () => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(async () => Promise.resolve([equipment1, equipment2]));

      await assetManager.setCurrentAsset(asset);
      await sleep(200);

      // Act
      const currentEquipment = equipmentManager.getCurrentEquipment();

      // Assert
      expect(equipmentProxy.fetchEquipments).toBeCalledTimes(1);
      expect(currentEquipment).toEqual(equipment1);
    });

    it('Should return undefined when the current asset is undefined.', async () => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(async () => Promise.resolve([equipment1, equipment2]));

      await assetManager.setCurrentAsset(asset);
      await sleep(200);

      await assetManager.setCurrentAsset(undefined);
      await sleep(200);

      // Act
      const currentEquipment = equipmentManager.getCurrentEquipment();

      // Assert
      expect(equipmentProxy.fetchEquipments).toBeCalledTimes(1);
      expect(currentEquipment).toEqual(undefined);
    });
  });

  describe('setCurrentEquipment', () => {
    it('Should notify the listeners when the current equipment changed', (done) => {
      // Arrange

      // Act
      equipmentManager.setCurrentEquipment(equipment1);

      // Assert
      expect(currentEquipmentListener).toBeCalledTimes(1);
      expect(currentEquipmentListener.mock.calls[0][0]).toBe(equipment1);
      done();
    });

    it('Should notify the listeners when the current equipment changed', (done) => {
      // Arrange
      const anotherListener = jest.fn();
      equipmentManager.registerOnCurrentEquipmentChanged(anotherListener);

      // Act
      equipmentManager.setCurrentEquipment(equipment1);

      // Assert
      expect(anotherListener).toBeCalledTimes(1);
      expect(anotherListener.mock.calls[0][0]).toBe(equipment1);

      equipmentManager.unregisterOnCurrentEquipmentChanged(anotherListener);
      done();
    });

    it('Should not notify the unregister listener when the current equipment changed', (done) => {
      // Arrange
      const anotherListener = jest.fn();
      equipmentManager.registerOnCurrentEquipmentChanged(anotherListener);

      equipmentManager.setCurrentEquipment(equipment1);

      equipmentManager.unregisterOnCurrentEquipmentChanged(anotherListener);

      // Act
      equipmentManager.setCurrentEquipment(equipment2);

      // Assert
      expect(anotherListener).toBeCalledTimes(1);
      expect(anotherListener.mock.calls[0][0]).toBe(equipment1);

      done();
    });
  });

  describe('getEquipments', () => {
    it('should return the equipments fetched', async () => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(async () => Promise.resolve([equipment1, equipment2]));

      await assetManager.setCurrentAsset(asset);
      await sleep(200);

      // Act
      const equipments = equipmentManager.getEquipments();

      // Assert
      expect(equipments.length).toBe(2);
      expect(equipments[0]).toBe(equipment1);
      expect(equipments[1]).toBe(equipment2);
    });
  });

  describe('onEquipmentDeleted', () => {
    it('should remove the equipment from the list and it should notify the listeners', async () => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(async () => Promise.resolve([equipment1, equipment2]));

      await assetManager.setCurrentAsset(asset);
      await sleep(200);

      // Act
      equipmentManager.onEquipmentDeleted(equipment1);

      // Assert
      const equipments = equipmentManager.getEquipments();
      expect(equipments.length).toBe(1);
      expect(equipments[0]).toBe(equipment2);
      expect(equipmentsListener).toBeCalledTimes(2);
    });

    it('should not notify the unregistered listeners', async () => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(async () => Promise.resolve([equipment1, equipment2]));

      const anotherEquipmentsListener = jest.fn();
      equipmentManager.registerOnEquipmentsChanged(anotherEquipmentsListener);

      await assetManager.setCurrentAsset(asset);
      await sleep(200);

      equipmentManager.unregisterOnEquipmentsChanged(anotherEquipmentsListener);

      // Act
      equipmentManager.onEquipmentDeleted(equipment1);

      // Assert
      expect(anotherEquipmentsListener).toBeCalledTimes(1);
    });
  });

  describe('onEquipmentSaved', () => {
    it('should add the equipment from the list and it should notify the listeners', async () => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(async () => Promise.resolve([equipment1, equipment2]));

      await assetManager.setCurrentAsset(asset);
      await sleep(200);

      const equipment3 = {
        _uiId: 'an id generated by the front 3',
        name: 'sail',
        brand: 'sail',
        model: 'N3.30',
        age: 2563,
        installation: new Date(1979, 6, 1),
        ageAcquisitionType: 1,
        ageUrl: '',
      };

      // Act
      equipmentManager.onEquipmentSaved(equipment3);

      // Assert
      const equipments = equipmentManager.getEquipments();
      expect(equipments.length).toBe(3);
      expect(equipments[2]).toEqual(equipment3);
      expect(equipmentsListener).toBeCalledTimes(2);
    });

    it('should update the equipment from the list and it should notify the listeners', async () => {
      // Arrange
      equipmentProxy.fetchEquipments.mockImplementation(async () => Promise.resolve([equipment1, equipment2]));

      await assetManager.setCurrentAsset(asset);
      await sleep(200);

      const copyEquipment1 = { ...equipment1 };
      copyEquipment1.age = 12345;

      // Act
      equipmentManager.onEquipmentSaved(copyEquipment1);

      // Assert
      const equipments = equipmentManager.getEquipments();
      expect(equipments.length).toBe(2);
      expect(equipments[0]).toEqual(copyEquipment1);
      expect(equipmentsListener).toBeCalledTimes(2);
    });
  });
});
